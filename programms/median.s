.text
median:
.globl median
    # в a0 - адрес 0-го элемента массива
    # в a1 - длина массива 
    
    li t0, 2             # в t0 помещаем 2
    li t1, 4             # в t1 помещаем 4  
    rem a2, a1, t0       # получаем остаток от деления длины массива на 2
    bnez a2, odd         # если остаток 0, выполняется код далее (even), если нет выполняется код блока odd
    even:
        div a2, a1, t0   # делим нацело на 2
        mul a2, a2, t1   # умножаем на 4
        add a2, a0, a2   # прибавляем к адресу первого элемента массива полученный индекс и запоминаем его в x12
        lw a3, 0(a2)     # берём элемент, адрес которого был получен на предыдущем шаге, и запоминаем его в x13
        lw a4, -4(a2)    # берём предыдущий элемент и запоминаем его в x14
        add a3, a4, a3   # складываем элементы
        div a0, a3, t0   # делим сумму нацело на 2 и сохраняем результат в x10
        li a1, 5         # x11 = 5, устанавливаем регистр x11 в значение дробной части результат
        beqz x0, exit    # if x0 = 0 (always true) - exit
    odd: 
        div a2, a1, t0   # делим нацело на 2
        mul a2, a2, t1   # умножаем на 4
        add a2, a0, a2   # прибавляем к адресу первого элемента массива полученный индекс и запоминаем его в x12
        lw a0, 0(a2)     # берём элемент находящийся по этому адресу и сохраняем в x10
        li a1, 0         # т.к. результат целый, программа должна возвращать в регистре для дробной части 0
        beqz x0, exit    # if x0 = 0 (always true) - exit
    exit:
        ret              # jalr zero, ra, 0