  .rodata
array:
	.word 0, 4, 7, 12, 43, 45, 60, 100
array_len:
	.word 8

.data
int_res:
        .word 10
fract_res: 
        .word 10

.text
start:
.globl start

    la a0, array 		# считываем адрес первого элемента массива в регистр 10
    lw a1, array_len 		# считываем длину массива в регистр 11
    
    li t0, 2 
    li t1, 4    
    rem a1, a1, t0		# получаем остаток от делени€ длины массива на 2
    bnez a1, odd 		# если остаток 0, выполн€етс€ код далее (even), если нет выполн€етс€ код блока odd
    even:
        lw a1, array_len 	# берЄм длину массива
        div a1, a1, t0 		# делим нацело на 2
        mul a1, a1, t1 		# умножаем на 4
        add a2, a0, a1 		# прибавл€ем к адресу первого элемента массива полученный индекс и запоминаем его в x12
        lw a3, 0(a2)		# берЄм элемент, адрес которого был получен на предыдущем шаге, и запоминаем его в x13
        lw a4, -4(a2) 		# берЄм предыдущий элемент и запоминаем его в x14
        add a4, a4, a3 		# складываем элементы
        div a0, a4, t0 		# делим сумму на 2 и сохран€ем результат в int_res
        li a1, 5 			# x11 = 5, устанавливаем регистр x11 в значение дробной части результата
        la a2, fract_res 		# берЄм x12 адрес €чейки дл€ дробной части результата
        sw a1, 0(a2) 		# записываем в пам€ть дробную часть результата
        beqz x0, exit
    odd: 
        lw a1, array_len 	# берЄм длину массива
        div a1, a1, t0 		# делим нацело на 2
        mul a1, a1, t1 		# умножаем на 4
        add a2, a0, a1		# прибавл€ем к адресу первого элемента массива полученный индекс и запоминаем его в x12
        lw a0, 0(a2) 		# берЄм элемент наход€щийс€ по этому адресу и сохран€ем в x10
        beqz x0, exit 
    exit:
        la a2, int_res 		# берЄм в x12 адрес €чейки дл€ целой части результата
        sw a0, 0(a2) 		# записываем в пам€ть целую часть результата
        li a0, 17 			# x10 = 17
        ecall 			# ecall при значении x10 = 17 => останов симул€тора
